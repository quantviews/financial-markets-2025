# AUTOGENERATED! DO NOT EDIT! File to edit: Russian_corporate_data_RFSD_2025.ipynb.

# %% auto 0
__all__ = ['OKVED_PATH', 'okved_df', 'examples', 'oil_codes', 'RFSD_PATH', 'key_columns', 'lf_2024', 'lf_filtered',
           'df_2024_sample', 'lf_with_ratios', 'lf_valid_ratios', 'df_with_ratios', 'decode_okved',
           'find_okved_by_keyword', 'load_rfsd_year_polars', 'rename_rfsd_columns', 'get_org_name_from_kontur',
           'calculate_financial_ratios_polars']

# %% Russian_corporate_data_RFSD_2025.ipynb 5
# Загрузка справочника ОКВЭД 2
import json
from pathlib import Path
import polars as pl

OKVED_PATH = Path("../metadata/okved_2.json")

# Загружаем справочник ОКВЭД
with open(OKVED_PATH, 'r', encoding='utf-8') as f:
    okved_dict = json.load(f)

# Конвертируем в Polars DataFrame для удобной работы
okved_df = pl.DataFrame(okved_dict)

print(f"Загружено {len(okved_df):,} кодов ОКВЭД")
print(f"\nСтруктура справочника:")
print(okved_df.head())
print(f"\nСтолбцы: {okved_df.columns}")


# %% Russian_corporate_data_RFSD_2025.ipynb 6
# Функция для расшифровки кода ОКВЭД
def decode_okved(code, okved_data=okved_df):
    """
    Расшифровывает код ОКВЭД, возвращая название и описание
    
    Parameters:
    -----------
    code : str
        Код ОКВЭД (например, "46.35.1" или "01.11")
    okved_data : pl.DataFrame
        DataFrame со справочником ОКВЭД
        
    Returns:
    --------
    dict
        Словарь с информацией о коде ОКВЭД
    """
    result = okved_data.filter(pl.col('code') == code)
    
    if len(result) > 0:
        row = result.row(0, named=True)
        return {
            'code': row['code'],
            'name': row['name'],
            'section': row['section'],
            'parent_code': row.get('parent_code', None),
            'comment': row.get('comment', '')
        }
    else:
        return None

# Примеры использования
examples = ['46.35.1', '01.11', '06.10']
print("Примеры расшифровки кодов ОКВЭД:")
for code in examples:
    decoded = decode_okved(code)
    if decoded:
        print(f"\nКод: {decoded['code']}")
        print(f"Название: {decoded['name']}")
        print(f"Секция: {decoded['section']}")
    else:
        print(f"\nКод {code} не найден в справочнике")


# %% Russian_corporate_data_RFSD_2025.ipynb 7
# Поиск кодов ОКВЭД по ключевым словам
def find_okved_by_keyword(keyword, okved_data=okved_df):
    """
    Находит коды ОКВЭД по ключевому слову в названии
    
    Parameters:
    -----------
    keyword : str
        Ключевое слово для поиска
    okved_data : pl.DataFrame
        DataFrame со справочником ОКВЭД
        
    Returns:
    --------
    pl.DataFrame
        DataFrame с найденными кодами ОКВЭД
    """
    return (
        okved_data
        .filter(pl.col('name').str.to_lowercase().str.contains(keyword.lower()))
        .select(['code', 'name', 'section'])
    )

# Пример: поиск кодов связанных с нефтью
print("Коды ОКВЭД, связанные с 'нефть':")
oil_codes = find_okved_by_keyword('нефт')
print(oil_codes.head(10))


# %% Russian_corporate_data_RFSD_2025.ipynb 29
RFSD_PATH = Path('E:/YandexDisk/Russia/RFSD')
print("RFSD_PATH есть:", RFSD_PATH.exists())


# %% Russian_corporate_data_RFSD_2025.ipynb 31
def load_rfsd_year_polars(
    year, 
    rfsd_path=RFSD_PATH,
    columns=None,
    filters=None,
    lazy=True
):
    """
    Эффективно загружает данные RFSD за указанный год используя Polars.
    
    Parameters:
    -----------
    year : int
        Год данных (2011-2024)
    rfsd_path : Path
        Путь к папке с данными RFSD
    columns : list of str, optional
        Список столбцов для загрузки (None = все столбцы)
    filters : list, optional
        Список фильтров Polars для применения при чтении
    lazy : bool
        Если True, возвращает LazyFrame (рекомендуется для больших данных)
        
    Returns:
    --------
    pl.DataFrame or pl.LazyFrame or None
        DataFrame/LazyFrame с данными за указанный год или None в случае ошибки.
    """
    rfsd_path = Path(rfsd_path)
    year_path = rfsd_path / f"year={year}"
    
    if not year_path.exists():
        warnings.warn(f"Данные за {year} год не найдены по пути {year_path}")
        return None
    
    try:
        # Используем scan_parquet для эффективной загрузки
        lf = pl.scan_parquet(str(year_path / "*.parquet"))
    except Exception as e:
        warnings.warn(f"Не удалось загрузить данные за {year} год. Ошибка: {e}")
        return None
    
    # Применяем фильтры если указаны (predicate pushdown)
    if filters is not None:
        for filter_expr in filters:
            lf = lf.filter(filter_expr)
    
    # Выбираем только нужные столбцы если указаны
    if columns is not None:
        lf = lf.select(columns)
    
    if lazy:
        print(f"Создан LazyFrame для {year} года")
        if columns:
            print(f"Выбрано {len(columns)} переменных из доступных")
        print("Используйте .collect() для выполнения вычислений")
        return lf
    else:
        df = lf.collect()
        print(f"Загружено {len(df):,} наблюдений за {year} год")
        if columns:
            print(f"Загружено {len(columns)} переменных из доступных")
        else:
            print(f"Загружено {len(df.columns)} переменных")
        return df


# %% Russian_corporate_data_RFSD_2025.ipynb 33
# Пример 1: Загрузка только ключевых столбцов за 2024 год (эффективно!)
key_columns = [
    # Идентификаторы и классификаторы
    'inn', 'ogrn', 'region', 'okved', 'okved_section',
    
    # Форма №2 (Отчет о финансовых результатах)
    'line_2110',  # Выручка
    'line_2300',  # Прибыль (убыток) до налогообложения
    'line_2320',  # Проценты к получению
    'line_2330',  # Проценты к уплате
    'line_2400',  # Чистая прибыль (убыток)
    
    # Форма №1 (Бухгалтерский баланс) - Активы
    'line_1100',  # Внеоборотные активы
    'line_1200',  # Оборотные активы (для расчета текущей ликвидности)
    'line_1250',  # Денежные средства и денежные эквиваленты
    'line_1600',  # Активы всего
    
    # Форма №1 (Бухгалтерский баланс) - Пассивы
    'line_1300',  # Капитал и резервы
    'line_1400',  # Долгосрочные обязательства
    'line_1500',  # Краткосрочные обязательства
    'line_1700',  # Пассивы всего
    
    # Форма №4 (Отчет о движении денежных средств)
    'line_4221',  # Платежи в связи с приобретением внеоборотных активов
    
    # Метаданные
    'filed', 'eligible'
]

# Сначала создаем LazyFrame (ничего не загружается в память)
lf_2024 = load_rfsd_year_polars(2024, columns=key_columns, lazy=True)

# Теперь можем применять фильтры и только потом загружать
# Например, только компании с поданной отчетностью и выручкой > 100 млн руб.
lf_filtered = lf_2024.filter(
    (pl.col('filed') == 1) & 
    (pl.col('line_2110') >= 100_000) 
)


# %% Russian_corporate_data_RFSD_2025.ipynb 34
# Только сейчас (collect) загружаем данные 
df_2024_sample = lf_filtered.collect()
print(f"\nЗагружено {len(df_2024_sample):,} компаний после фильтрации")

# %% Russian_corporate_data_RFSD_2025.ipynb 40
# функция переименования (фильтрует только существующие столбцы)
def rename_rfsd_columns(df, use_descriptive_names=True):
    """
    Переименовывает столбцы RFSD в описательные названия 
    
    Parameters:
    -----------
    df : pl.DataFrame или pl.LazyFrame
        DataFrame с данными RFSD
    use_descriptive_names : bool
        Если True, загружает и применяет описательные названия из GitHub
        
    Returns:
    --------
    pl.DataFrame или pl.LazyFrame
        DataFrame с переименованными столбцами
    """
    if not use_descriptive_names:
        return df
    
    # Загружаем словарь переименований из GitHub репозитория RFSD
    renaming_df = pl.read_csv(
        'https://raw.githubusercontent.com/irlcode/RFSD/main/aux/descriptive_names_dict.csv'
    )
    
    # Создаем полный словарь для переименования
    full_rename_dict = {
        row[0]: row[1] 
        for row in renaming_df.select(['original', 'descriptive']).iter_rows()
    }
    
    # Получаем список столбцов DataFrame (работает и для DataFrame, и для LazyFrame)
    if hasattr(df, 'columns'):
        # DataFrame
        available_columns = df.columns
    elif hasattr(df, 'schema'):
        # LazyFrame - получаем столбцы из схемы
        available_columns = list(df.schema.keys())
    else:
        available_columns = []
    
    # Фильтруем словарь: оставляем только те столбцы, которые есть в DataFrame
    rename_dict = {
        old_name: new_name 
        for old_name, new_name in full_rename_dict.items() 
        if old_name in available_columns
    }
    
    if not rename_dict:
        print("Предупреждение: не найдено столбцов для переименования")
        return df
    
    # Применяем переименование с strict=False для безопасности
    df_renamed = df.rename(rename_dict, strict=False)
    
    print(f"Переименовано {len(rename_dict)} из {len(full_rename_dict)} доступных столбцов")
    print("Примеры переименований:")
    sample_renames = list(rename_dict.items())[:5]
    for orig, desc in sample_renames:
        print(f"  {orig} → {desc}")
    
    return df_renamed



# %% Russian_corporate_data_RFSD_2025.ipynb 49
import requests
from bs4 import BeautifulSoup
import json

def get_org_name_from_kontur(query: str, timeout: int = 10) -> str | None:
    url = f"https://focus.kontur.ru/entity?query={query}"

    headers = {
        "User-Agent": (
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
            "AppleWebKit/537.36 (KHTML, like Gecko) "
            "Chrome/120.0.0.0 Safari/537.36"
        )
    }

    # Загружаем как байты
    resp = requests.get(url, headers=headers, timeout=timeout)
    resp.raise_for_status()

    # Насильно задаём кодировку UTF-8
    resp.encoding = "utf-8"

    soup = BeautifulSoup(resp.text, "html.parser")

    script_tag = soup.find("script", id="entity", type="application/json")
    if script_tag is None or not script_tag.string:
        return None

    data = json.loads(script_tag.string)

    # Краткое название
    if "name" in data:
        return data["name"]

    # Если нет, берём title до ", ИНН"
    if "title" in data:
        return data["title"].split(", ИНН")[0].strip()

    return None


# %% Russian_corporate_data_RFSD_2025.ipynb 66
# Расчет финансовых показателей в Polars (очень эффективно!)
# Polars позволяет делать это на уровне LazyFrame до загрузки данных

def calculate_financial_ratios_polars(lf):
    """
    Рассчитывает финансовые показатели используя Polars LazyFrame
    
    Parameters:
    -----------
    lf : pl.LazyFrame
        LazyFrame с финансовыми данными
        
    Returns:
    --------
    pl.LazyFrame
        LazyFrame с добавленными финансовыми показателями:
        - ros: Рентабельность продаж (ROS)
        - roa: Рентабельность активов (ROA)
        - leverage: Долговая нагрузка
        - debt_to_equity: Долг/Собственный капитал
        - ebit: EBIT по РСБУ (Прибыль до налогообложения + Проценты к уплате)
        - ebitda: EBITDA по РСБУ (EBIT + Амортизация, упрощенно ≈ EBIT если амортизация недоступна)
        - ebitda_margin: EBITDA Margin (EBITDA / Выручка)
        - interest_to_revenue: Процентные платежи к выручке
        - interest_to_assets: Процентные платежи к активам
        - interest_coverage: Покрытие процентов прибылью (Interest Coverage Ratio)
        - interest_to_net_profit: Процентные платежи к чистой прибыли
    """
    return lf.with_columns([
        # Рентабельность продаж (ROS)
        (pl.col('line_2400') / pl.col('line_2110')).alias('ros'),
        
        # Рентабельность активов (ROA)
        (pl.col('line_2400') / pl.col('line_1600')).alias('roa'),
        
        # Долговая нагрузка (Leverage)
        ((pl.col('line_1400') + pl.col('line_1500')) / pl.col('line_1600')).alias('leverage'),
        
        # Долг/Собственный капитал
        ((pl.col('line_1400') + pl.col('line_1500')) / pl.col('line_1300')).alias('debt_to_equity'),
        
        # EBIT (Earnings Before Interest and Taxes) по РСБУ
        # Формула: EBIT = Чистая прибыль (line_2400) + Налог на прибыль (line_2410) + Проценты к уплате (line_2330)
        # Альтернативно: EBIT = Прибыль до налогообложения (line_2300) + Проценты к уплате (line_2330)
        # т.к. line_2300 = line_2400 + line_2410
        (
            pl.col('line_2300') + pl.col('line_2330').fill_null(0)
        ).alias('ebit'),
        
        # EBITDA (Earnings Before Interest, Taxes, Depreciation and Amortization) по РСБУ
        # Формула: EBITDA = EBIT + Амортизация
        # Полная формула: EBITDA = Чистая прибыль (line_2400) + Налог на прибыль (line_2410) + 
        #                   Проценты к уплате (line_2330) + Амортизация
        # Примечание: Амортизация обычно берется из формы №5 (строка 5640), 
        #             но в RFSD отсутствует. В этом случае используем упрощенную формулу:
        #             EBITDA ≈ EBIT (без учета амортизации)
        (
            pl.col('line_2300') + pl.col('line_2330').fill_null(0)
        ).alias('ebitda'),
        
        # EBITDA Margin (EBITDA / Выручка)
        (
            (pl.col('line_2300') + pl.col('line_2330').fill_null(0)) / pl.col('line_2110')
        ).alias('ebitda_margin'),
        
        # Процентные платежи к выручке (Interest to Revenue)
        (
            pl.col('line_2330').fill_null(0) / pl.col('line_2110')
        ).alias('interest_to_revenue'),
        
        # Процентные платежи к активам (Interest to Assets)
        (
            pl.col('line_2330').fill_null(0) / pl.col('line_1600')
        ).alias('interest_to_assets'),
        
        # Покрытие процентов прибылью (Interest Coverage Ratio)
        # Прибыль до налогообложения / Проценты к уплате
        (
            pl.col('line_2300') / pl.col('line_2330').fill_null(1)
        ).alias('interest_coverage'),
        
        # Процентные платежи к чистой прибыли (Interest to Net Profit)
        # Проценты к уплате / Чистая прибыль
        # Если чистая прибыль <= 0, результат будет отрицательным или бесконечным
       (
    pl.col('line_2330').fill_null(0) / pl.when(pl.col('line_2400') == 0.0).then(None).otherwise(pl.col('line_2400'))).alias('interest_to_net_profit'),
        # Текущая ликвидность (Current Ratio)
        (pl.col('line_1200') / pl.col('line_1500')).alias('current_ratio'),
    ])

# Применяем расчеты на уровне LazyFrame
lf_with_ratios = calculate_financial_ratios_polars(lf_filtered)

# Фильтруем только валидные значения (избегаем деления на ноль)
lf_valid_ratios = lf_with_ratios.filter(
    (pl.col('ros').is_finite()) &
    (pl.col('roa').is_finite()) &
    (pl.col('leverage').is_finite()) &
    (pl.col('ebit').is_finite()) &
    (pl.col('ebitda').is_finite()) &
    (pl.col('ebitda_margin').is_finite()) &
    (pl.col('interest_to_revenue').is_finite()) &
    (pl.col('interest_to_assets').is_finite()) &
    (pl.col('interest_coverage').is_finite()) &
    (pl.col('interest_to_net_profit').is_finite())
)



# %% Russian_corporate_data_RFSD_2025.ipynb 67
# Загружаем только результат
df_with_ratios = lf_valid_ratios.collect()
print(f"Рассчитаны показатели для {len(df_with_ratios):,} компаний")

# Показываем результаты
df_with_ratios.select([
    'inn', 'region', 'okved_section',
    'line_2110', 'line_2300', 'line_2330', 'line_2400', 'line_1600',
    'ros', 'roa', 'leverage', 'debt_to_equity',
    'ebit', 'ebitda', 'ebitda_margin',
    'interest_to_revenue', 'interest_to_assets', 'interest_coverage', 'interest_to_net_profit'
]).head(10)

